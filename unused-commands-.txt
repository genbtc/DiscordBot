	"beam": {
		usage: "<stream>",
		description: "checks if the given Beam stream is online",
		process: function(bot,msg,suffix){
		    require("request")("https://beam.pro/api/v1/channels/"+suffix,
		    function(err,res,body){
		        var data = JSON.parse(body);
		        if(data && data.online){
		            msg.channel.sendMessage( suffix
		                +" is online"
		                +"\n"+data.thumbnail.url)
		        }else{
		            msg.channel.sendMessage( suffix+" is offline")
		        }
		    });
		}
	},
    "eval": {
		usage: "<command>",
		description: 'Executes arbitrary javascript in the bot process. User must have "eval" permission',
		process: function(bot,msg,suffix) {
			if(Permissions.checkPermission(msg.author,"eval")){
				msg.channel.sendMessage( eval(suffix,bot));
			} else {
				msg.channel.sendMessage( msg.author + " doesn't have permission to execute eval!");
			}
		}
	},
    "log": {
        usage: "<log message>",
        description: "logs message to bot console",
        process: function(bot,msg,suffix){console.log(msg.content);}
    },
    "version": {
        description: "returns the git commit this bot is running",
        process: function(bot,msg,suffix) {
            var commit = require('child_process').spawn('git', ['log','-n','1']);
            commit.stdout.on('data', function(data) {
                msg.channel.sendMessage(data);
            });
            commit.on('close',function(code) {
                if( code != 0){
                    msg.channel.sendMessage("failed checking git version!");
                }
            });
        }
    },    
    "delete": {
        usage: "<channel name>",
        description: "deletes the specified channel",
        process: function(bot,msg,suffix) {
			var channel = bot.channels.find("id",suffix);
			if(suffix.startsWith('<#')){
				channel = bot.channels.find("id",suffix.substr(2,suffix.length-3));
			}
            if(!channel){
				var channels = msg.channel.guild.channels.findAll("name",suffix);
				if(channels.length > 1){
					var response = "Multiple channels match, please use id:";
					for(var i=0;i<channels.length;i++){
						response += channels[i] + ": " + channels[i].id;
					}
					msg.channel.sendMessage(response);
					return;
				}else if(channels.length == 1){
					channel = channels[0];
				} else {
					msg.channel.sendMessage( "Couldn't find channel " + suffix + " to delete!");
					return;
				}
			}
            msg.channel.guild.defaultChannel.sendMessage("deleting channel " + suffix + " at " +msg.author + "'s request");
            if(msg.channel.guild.defaultChannel != msg.channel){
                msg.channel.sendMessage("deleting " + channel);
            }
            channel.delete().then(function(channel){
				console.log("deleted " + suffix + " at " + msg.author + "'s request");
            }).catch(function(error){
				msg.channel.sendMessage("couldn't delete channel: " + error);
			});
        }
    },    
	"voice": {
		usage: "<channel name>",
		description: "creates a new voice channel with the give name.",
		process: function(bot,msg,suffix) {
            msg.channel.guild.createChannel(suffix,"voice").then(function(channel) {
                msg.channel.sendMessage("created " + channel.id);
				console.log("created " + channel);
            }).catch(function(error){
				msg.channel.sendMessage("failed to create channel: " + error);
			});
        }
	},    
    "create": {
        usage: "<channel name>",
        description: "creates a new text channel with the given name.",
        process: function(bot,msg,suffix) {
            msg.channel.guild.createChannel(suffix,"text").then(function(channel) {
                msg.channel.sendMessage("created " + channel);
            }).catch(function(error){
				msg.channel.sendMessage("failed to create channel: " + error);
			});
        }
    },
    "pullanddeploy": {
        description: "bot will perform a git pull master and restart with the new code",
        process: function(bot,msg,suffix) {
            msg.channel.sendMessage("fetching updates...").then(function(sentMsg){
                console.log("updating...");
	            var spawn = require('child_process').spawn;
                var log = function(err,stdout,stderr){
                    if(stdout){console.log(stdout);}
                    if(stderr){console.log(stderr);}
                };
                var fetch = spawn('git', ['fetch']);
                fetch.stdout.on('data',function(data){
                    console.log(data.toString());
                });
                fetch.on("close",function(code){
                    var reset = spawn('git', ['reset','--hard','origin/master']);
                    reset.stdout.on('data',function(data){
                        console.log(data.toString());
                    });
                    reset.on("close",function(code){
                        var npm = spawn('npm', ['install']);
                        npm.stdout.on('data',function(data){
                            console.log(data.toString());
                        });
                        npm.on("close",function(code){
                            console.log("goodbye");
                            sentMsg.edit("brb!").then(function(){
                                bot.destroy().then(function(){
                                    process.exit();
                                });
                            });
                        });
                    });
                });
            });
        }
    },
    "setUsername":{
			description: "sets the username of the bot. Note this can only be done twice an hour!",
			process: function(bot,msg,suffix) {
				bot.user.setUsername(suffix);
			}
    },    
    "idle": {
        usage: "[status]",
        description: "sets bot status to idle",
        process: function(bot,msg,suffix){ bot.user.setStatus("idle",suffix);}
    },
    "online": {
        usage: "[status]",
        description: "sets bot status to online",
        process: function(bot,msg,suffix){ bot.user.setStatus("online",suffix);}
    },    